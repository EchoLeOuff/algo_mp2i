----------------------------Boyer-Moore----------------------------

Explication : L’algorithme de Boyer-Moore est une méthode efficace de recherche de motif dans un texte. Il compare le motif de droite à gauche, 
              et utilise deux heuristiques (mauvais caractère et bons suffixes) pour décaler intelligemment le motif sur le texte, sautant ainsi plusieurs positions, 
              ce qui accélère la recherche.

Code en C : 

void preprocess_bad_char(char *pattern, int m, int badChar[ALPHABET_SIZE]) {
    for (int i = 0; i < ALPHABET_SIZE; i++)
        badChar[i] = -1;
    for (int i = 0; i < m; i++)
        badChar[(unsigned char)pattern[i]] = i;
}

void boyer_moore(char *text, char *pattern) {
    int n = strlen(text);
    int m = strlen(pattern);
    int badChar[ALPHABET_SIZE];

    preprocess_bad_char(pattern, m, badChar);

    int s = 0;  // décalage du motif
    while (s <= n - m) {
        int j = m - 1;
        while (j >= 0 && pattern[j] == text[s + j])
            j--;
        if (j < 0) {
            printf("Pattern trouvé à l'indice %d\n", s);
            s += (s + m < n) ? m - badChar[(unsigned char)text[s + m]] : 1;
        } else {
            int shift = j - badChar[(unsigned char)text[s + j]];
            s += (shift > 1) ? shift : 1;
        }
    }
}

Code en Ocaml : 

let preprocess_bad_char pattern =
  let bad_char = Array.make alphabet_size (-1) in
  for i = 0 to String.length pattern - 1 do
    bad_char.(Char.code pattern.[i]) <- i
  done;
  bad_char

let boyer_moore text pattern =
  let n = String.length text in
  let m = String.length pattern in
  let bad_char = preprocess_bad_char pattern in
  let rec search s =
    if s <= n - m then
      let rec match_from j =
        if j < 0 then (
          Printf.printf "Pattern trouvé à l'indice %d\n" s;
          let next_shift =
            if s + m < n then m - bad_char.(Char.code text.[s + m]) else 1
          in
          search (s + next_shift)
        ) else if pattern.[j] = text.[s + j] then
          match_from (j - 1)
        else
          let shift = j - bad_char.(Char.code text.[s + j]) in
          search (s + (if shift > 1 then shift else 1))
      in
      match_from (m - 1)
  in
  search 0

-----------------------------BMHorspool-----------------------------

Explication : Boyer-Moore-Horspool créer une table de décalage par rapport au motif et les lettres qui le compose 
Code en C : 

void preprocessBadChar(char *pattern, int m, int badChar[MAX]) {
    for (int i = 0; i < MAX; i++) {
        badChar[i] = m; // Initialiser à la longueur du motif
    }
    for (int i = 0; i < m - 1; i++) {
        badChar[(unsigned char)pattern[i]] = m - 1 - i; // Distance au dernier caractère
    }
}

int bmHorspool(char *text, char *pattern) {
    int n = strlen(text);
    int m = strlen(pattern);
    if (m == 0 || n < m) return -1;

    int badChar[MAX];
    preprocessBadChar(pattern, m, badChar);

    int s = 0; // Décalage courant
    while (s <= n - m) {
        int j = m - 1;
        while (j >= 0 && pattern[j] == text[s + j]) {
            j--;
        }
        if (j < 0) {
            return s; // Motif trouvé
        }
        s += badChar[(unsigned char)text[s + m - 1]]; // Décalage basé sur le caractère non apparié
    }
    return -1; // Motif non trouvé
}

Code en Ocaml : 

let max = 256

let preprocess_bad_char pattern m =
  let bad_char = Array.make max m in
  for i = 0 to m - 2 do
    bad_char.(int_of_char pattern.[i]) <- m - 1 - i
  done;
  bad_char

let bm_horspool text pattern =
  let n = String.length text in
  let m = String.length pattern in
  if m = 0 || n < m then -1
  else
    let bad_char = preprocess_bad_char pattern m in
    let rec search s =
      if s > n - m then -1
      else
        let rec compare j =
          if j < 0 then s
          else if pattern.[j] = text.[s + j] then compare (j - 1)
          else search (s + bad_char.(int_of_char text.[s + m - 1]))
        in
        compare (m - 1)
    in
    search 0
